import pandas as pd
import numpy as np

import torch
import torch.nn.functional as F

from sklearn.utils.class_weight import compute_class_weight

from transformers.models.detr.modeling_detr import DetrLoss

def compute_class_weights(dataframe, pos_f=0.25):
    dataframe = dataframe[~dataframe.bbox.isna()]

    pos_labels = dataframe.category_id.values
    neg_labels = np.zeros(pos_labels.shape[0] * int(1/pos_f - 1))
    labels = np.concatenate([pos_labels, neg_labels])

    weights = compute_class_weight("balanced", classes=np.unique(labels), y=labels)
    weights = torch.from_numpy(weights).to(torch.float32)
    return weights

def weighted_fastrcnn_loss(weights):
    def fastrcnn_loss(class_logits, box_regression, labels, regression_targets):
        # type: (Tensor, Tensor, List[Tensor], List[Tensor]) -> Tuple[Tensor, Tensor]
        """
        Computes the loss for Faster R-CNN.

        Args:
            class_logits (Tensor)
            box_regression (Tensor)
            labels (list[BoxList])
            regression_targets (Tensor)

        Returns:
            classification_loss (Tensor)
            box_loss (Tensor)
        """
        labels = torch.cat(labels, dim=0)
        regression_targets = torch.cat(regression_targets, dim=0)

        classification_loss = F.cross_entropy(class_logits, labels, weight=weights.to(labels.device))

        # get indices that correspond to the regression targets for
        # the corresponding ground truth labels, to be used with
        # advanced indexing
        sampled_pos_inds_subset = torch.where(labels > 0)[0]
        labels_pos = labels[sampled_pos_inds_subset]
        N, num_classes = class_logits.shape
        box_regression = box_regression.reshape(N, box_regression.size(-1) // 4, 4)

        box_loss = F.smooth_l1_loss(
            box_regression[sampled_pos_inds_subset, labels_pos],
            regression_targets[sampled_pos_inds_subset],
            beta=1 / 9,
            reduction="sum",
        )
        box_loss = box_loss / labels.numel()

        return classification_loss, box_loss

    return fastrcnn_loss

def fastrcnn_focal_loss(focal_loss):
    def fastrcnn_loss(class_logits, box_regression, labels, regression_targets):
        # type: (Tensor, Tensor, List[Tensor], List[Tensor]) -> Tuple[Tensor, Tensor]
        """
        Computes the loss for Faster R-CNN.

        Args:
            class_logits (Tensor)
            box_regression (Tensor)
            labels (list[BoxList])
            regression_targets (Tensor)

        Returns:
            classification_loss (Tensor)
            box_loss (Tensor)
        """
        labels = torch.cat(labels, dim=0)
        regression_targets = torch.cat(regression_targets, dim=0)

        classification_loss = focal_loss(class_logits, labels)

        # get indices that correspond to the regression targets for
        # the corresponding ground truth labels, to be used with
        # advanced indexing
        sampled_pos_inds_subset = torch.where(labels > 0)[0]
        labels_pos = labels[sampled_pos_inds_subset]
        N, num_classes = class_logits.shape
        box_regression = box_regression.reshape(N, box_regression.size(-1) // 4, 4)

        box_loss = F.smooth_l1_loss(
            box_regression[sampled_pos_inds_subset, labels_pos],
            regression_targets[sampled_pos_inds_subset],
            beta=1 / 9,
            reduction="sum",
        )
        box_loss = box_loss / labels.numel()

        return classification_loss, box_loss
    return fastrcnn_loss

class DetrLossCustom(DetrLoss):
    def __init__(self, matcher, num_classes, eos_coef, losses, class_weights):
        super(DetrLossCustom, self).__init__(matcher, num_classes, eos_coef, losses)
        self.empty_weight[:self.num_classes] = class_weights
import torch

def iou(boxesA, boxesB, inter_thr=0.8):
    inter_max_xy = torch.min(boxesA[:, None, 2:], boxesB[None, :, 2:])
    inter_min_xy = torch.max(boxesA[:, None, :2], boxesB[None, :, :2])
    inter = torch.clamp((inter_max_xy - inter_min_xy), min=0)
    inter_area = inter[..., 0] * inter[..., 1]

    areaA = ((boxesA[:, 2] - boxesA[:, 0]) * (boxesA[:, 3] - boxesA[:, 1])).unsqueeze(1)
    areaB = ((boxesB[:, 2] - boxesB[:, 0]) * (boxesB[:, 3] - boxesB[:, 1])).unsqueeze(0)

    union = areaA + areaB - inter_area
    iou = inter_area / union

    ratioA = inter_area / areaA
    ratioB = inter_area / areaB
    is_close_to_one = (ratioA > inter_thr) | (ratioB > inter_thr)
    iou[is_close_to_one] = 1

    torch.diagonal(iou, 0).fill_(0)
    return iou.squeeze()

def custom_nms(predictions, iou_thr=0.35, trash_thr=0.01, inter_thr=0.8, format='xywh'):
    suppressed_predictions = [] 
    for i, prediction in enumerate(predictions):
        scores, bboxes, labels = prediction['scores'], prediction['boxes'], prediction['labels']
        if format == 'xywh':
            bboxes[:,2:] = bboxes[:,2:] + bboxes[:,:2]

        if bboxes.shape[0]:
            idxs = torch.argsort(scores, descending=True)
            scores = scores[idxs]
            bboxes = bboxes[idxs]
            labels = labels[idxs]

            ious = iou(bboxes, bboxes, inter_thr)
            keep = torch.zeros_like(idxs, dtype=torch.bool, device=scores.device)
            keep[0] = True

            for idx in idxs:
                if scores[idx] > trash_thr and not keep[idx]:  
                    iou_ = ious[idx, keep]
                    if not iou_.gt(iou_thr).any():
                        keep[idx] = True

            if format == 'xywh':
                bboxes[:,2:] = bboxes[:,2:] - bboxes[:,:2]

            suppressed_predictions.append({
                'scores' : scores[keep],
                'boxes'  : bboxes[keep],
                'labels' : labels[keep]
            })

        else:
            suppressed_predictions.append({
                'scores' : scores,
                'boxes'  : bboxes,
                'labels' : labels
            })

    return suppressed_predictions

def filtering_by_mask(predictions, masks):
    filtered_predictions = []

    for prediction, mask in zip(predictions, masks):
        scores, bboxes, labels = prediction['scores'], prediction['boxes'], prediction['labels']

        if bboxes.shape[0]:
            keep = torch.ones(bboxes.shape[0], dtype=torch.bool, device=bboxes.device)
            for i, bbox in enumerate(bboxes):
                x1, y1, x2, y2 = bbox.long()

                if torch.any(mask[y1:y2+1, x1:x2+1]):
                    keep[i] = False

            filtered_predictions.append({
                'scores' : scores[keep],
                'boxes'  : bboxes[keep],
                'labels' : labels[keep]
            })
        
        else:
            filtered_predictions.append({
                'scores' : scores,
                'boxes'  : bboxes,
                'labels' : labels
            })

    return filtered_predictions

def process_detr_targets(targets):
    processed_targets = []

    for target in targets:
        target['boxes'][:, :2] = target['boxes'][:, :2] - target['boxes'][:, 2:] / 2
        processed_targets.append({
            'boxes'  : target['boxes'] * torch.cat([target['size'], target['size']]),
            'labels' : target['class_labels']
        })

    return processed_targets

def process_detr_predictions(predictions):
    processed_predictions = []

    for prediction in predictions:
        prediction['boxes'][:, 2:] = prediction['boxes'][:, 2:] - prediction['boxes'][:, :2]
        processed_predictions.append({
            'boxes'  : prediction['boxes'],
            'labels' : prediction['labels'],
            'scores' : prediction['scores']
        })

    return processed_predictions

        

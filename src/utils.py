import contextlib
import joblib
import numpy as np
import torch
import os
import random
import matplotlib.pyplot as plt 
import matplotlib.patches as patches

category_color_map = {1 : "red", 2 : "blue", 3 : "green"}
category_name_map =  {1 : "Other", 2 : "Tin", 3 : "Thatch"}


@contextlib.contextmanager
def tqdm_joblib(tqdm_object):
    """Context manager to patch joblib to report into tqdm progress bar given askimage.transform"""
    class TqdmBatchCompletionCallback(joblib.parallel.BatchCompletionCallBack):
        def __call__(self, *args, **kwargs):
            tqdm_object.update(n=self.batch_size)
            return super().__call__(*args, **kwargs)

    old_batch_callback = joblib.parallel.BatchCompletionCallBack
    joblib.parallel.BatchCompletionCallBack = TqdmBatchCompletionCallback
    try:
        yield tqdm_object
    finally:
        joblib.parallel.BatchCompletionCallBack = old_batch_callback
        tqdm_object.close()

def seed_everything(seed=17112000):
    random.seed(seed)
    os.environ['PYTHONHASHSEED'] = str(seed)
    np.random.seed(seed)
    torch.manual_seed(seed)
    torch.cuda.manual_seed(seed)
    torch.backends.cudnn.deterministic = True
    torch.backends.cudnn.benchmark = True

def estimate_maximum_batch_size(model, device, input_shape):
    batch = 1
    model = model.to(device)
    
    while True:
    
        torch.cuda.synchronize()
        x = torch.ones((batch,) + input_shape, dtype=torch.float32).to(device)
        try:
            model(x)
        except torch.cuda.OutOfMemoryError:
            batch = batch // 2

            return batch

        else:
            batch *= 2

def imgs2fig(image_array, boxes_infos):
    num_images = len(boxes_infos)
    fig, axs = plt.subplots(1, num_images, figsize=(num_images * 5, 5))
    
    if num_images == 1:
        axs = [axs] 
    
    for idx, (image_name, boxes_info) in enumerate(boxes_infos.items()):
        axs[idx].imshow(image_array)
        axs[idx].set_title(image_name)

        if boxes_info.get('scores', None) is None:
            print_scores = False
            boxes_info['scores'] = [0]*len(boxes_info['labels'])
        else:
            print_scores = True
        
        for box, category, score in zip(boxes_info['boxes'], boxes_info['labels'], boxes_info['scores']):
            x_min, y_min, x_max, y_max = box
            box_width = x_max - x_min
            box_height = y_max - y_min
            
            color = category_color_map.get(category, 'black')
            rect = patches.Rectangle((x_min, y_min), box_width, box_height, linewidth=2, edgecolor=color, facecolor='none')
            axs[idx].add_patch(rect)
            
            # if print_scores:
            #     label = f"{category_name_map.get(category, 'Unknown')}, {score:.2f}"
            # else:
            #     label = f"{category_name_map.get(category, 'Unknown')}"
            # axs[idx].text(x_min + 2, y_min + 5, label, color=color, bbox=dict(facecolor='white', alpha=0.5), clip_on=True)
        
        axs[idx].axis('off')
    
    plt.tight_layout()
    plt.close(fig)

    return fig

def dict2str(d):
    for key, value in d.items():
        if isinstance(value, dict):
            d[key] = dict2str(value)
        else:
            d[key] = str(value)

    return d
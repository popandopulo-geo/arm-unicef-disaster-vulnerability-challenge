import contextlib
import joblib
import numpy as np
import torch
import os
import random
import matplotlib.pyplot as plt 
from PIL import Image, ImageDraw

category_color_map = {1 : "red", 2 : "blue", 3 : "green"}
category_name_map =  {1 : "Other", 2 : "Tin", 3 : "Thatch"}


@contextlib.contextmanager
def tqdm_joblib(tqdm_object):
    """Context manager to patch joblib to report into tqdm progress bar given askimage.transform"""
    class TqdmBatchCompletionCallback(joblib.parallel.BatchCompletionCallBack):
        def __call__(self, *args, **kwargs):
            tqdm_object.update(n=self.batch_size)
            return super().__call__(*args, **kwargs)

    old_batch_callback = joblib.parallel.BatchCompletionCallBack
    joblib.parallel.BatchCompletionCallBack = TqdmBatchCompletionCallback
    try:
        yield tqdm_object
    finally:
        joblib.parallel.BatchCompletionCallBack = old_batch_callback
        tqdm_object.close()

def seed_everything(seed=17112000):
    random.seed(seed)
    os.environ['PYTHONHASHSEED'] = str(seed)
    np.random.seed(seed)
    torch.manual_seed(seed)
    torch.cuda.manual_seed(seed)
    torch.backends.cudnn.deterministic = True
    torch.backends.cudnn.benchmark = True

def estimate_maximum_batch_size(model, device, input_shape):
    batch = 1
    model = model.to(device)
    
    while True:
    
        torch.cuda.synchronize()
        x = torch.ones((batch,) + input_shape, dtype=torch.float32).to(device)
        try:
            model(x)
        except torch.cuda.OutOfMemoryError:
            batch = batch // 2

            return batch

        else:
            batch *= 2

def imgs2fig(image_array, boxes_infos):
    num_images = len(boxes_infos)
    fig, axs = plt.subplots(1, num_images, figsize=(num_images * 5, 5))
    
    if num_images == 1:
        axs = [axs] 
    
    for idx, (image_name, boxes_info) in enumerate(boxes_infos.items()):
        if boxes_info.get('scores', None) is None:
            print_scores = False
            boxes_info['scores'] = [0]*len(boxes_info['labels'])
        else:
            print_scores = True

        image = Image.fromarray(np.uint8(image_array))
        draw = ImageDraw.Draw(image, "RGB")
        
        for box, category, score in zip(boxes_info['boxes'], boxes_info['labels'], boxes_info['scores']):
            x, y, w, h = box
            box = (x,y,x+w,y+h)
            text = f'{category_name_map[category]} {score:.2f}' if print_scores else category_name_map[category]
            color = category_color_map[category]

            draw.rectangle(box, outline=color, width=3)
            draw.text((x, y), text, fill='white', font_size=20)
        
        axs[idx].imshow(np.array(image))
        axs[idx].set_title(image_name)
        axs[idx].axis('off')
    
    plt.tight_layout()
    plt.close(fig)

    return fig

def dict2str(d):
    for key, value in d.items():
        if isinstance(value, dict):
            d[key] = dict2str(value)
        else:
            d[key] = str(value)

    return d